GLOBAL = exports ? this

util = {}

###*
 * Special handling for regular expression literal since we need to
 * convert it to a string literal, otherwise it will be decoded
 * as object "{}" and the regular expression would be lost.
###
util.adjustRegexLiteral = (key, value) ->
  value.toString() if key is 'value' and value instanceof RegExp


###*
 * Convert codeMirror location object to 0 based index for lines
 * @param  {Location Object} loc has both 'line' and 'ch' positions.
 * @return {Location Object}     normalized location.
###
util.convertLoc = (loc) ->
  line: loc.line - 1
  column: loc.ch || loc.column

###*
 * Construct a CodeMirror Location object
 * @param  {int} line line number
 * @param  {int} ch   column number
 * @return {location}      location object
###
util.toLoc = (line, ch) ->
  line: line
  ch: ch

###*
 * Test to see if a position is within a codeMirror Range array
 * @param  {int} pos   position.
 * @param  {array} range (range[0], range[1]).
 * @return {boolean}       true if pos is within range, false otherwise.
###
util.withinRange = (pos, range) ->
  range? and range.length is 2 and range[0] <= pos <= range[1]


###*
 * Number to hex function
 * @param  {int} num    input.
 * @param  {int} length optional length of output. Default to the full length of the input.
 * @return {string}        hex number string.
###
util.toHex = (num, length) ->
  hex = Math.floor(num).toString(16)
  length ?= hex.length

  # Pad output
  for i in [0...length - hex.length]
    hex = "0" + hex

  hex.slice(-length)


###*
 * Map a value [0,1] to [min, max]
 * @param  {float} value a value between 0 and 1 inclusive.
 * @param  {float} min   lowerbound.
 * @param  {float} max   upperbound.
 * @return {float}       mapped value.
###
util.mapValue = (value, min, max) ->
  range = max - min
  value * range + min

###*
 * Insert helper functions on AST nodes
 * @param  {AST Node} node   AST generated by esprima
 * @param  {AST Node} parent AST generated by esprima
 * @param  {array} chunks chunks array of source code
 * @param  {int} depth  scope depth
###
util.insertHelpers = (node, parent, chunks, depth) ->
  return unless node.range

  node.depth = depth
  node.parent = parent
  node.source = ->
    chunks[node.range[0]...node.range[1]].join('')

  node.updateSource = (s) ->
    chunks[node.range[0]] = s
    chunks[i] = '' for i in [(node.range[0] + 1)...node.range[1]]
    s

  node.insertBefore = (s) ->
    chunks[node.range[0]] = s + '\n' + chunks[node.range[0]]
    s

  node.insertAfter = (s) ->
    chunks[node.range[1]] = chunks[node.range[1]] + '\n' + s
    s

  node

###*
 * Traverse AST
 * @param  {AST} ast      Generated by esprima
 * @param  {array} chunks   chunks array of source code
 * @param  {function} prefunc  function called on children then parent
 * @param  {function} postfunc function called on parent and then children
###
util.traverse = (ast, chunks, prefunc, postfunc) ->
  walk = (node, parent, depth = 0) =>
    postfunc.call(@, node, parent, chunks, depth) if postfunc?
    _.each node, (child, key) =>
      return if key in ['parent', 'range', 'loc']

      if _.isArray(child)
        _.each child, (grandchild) ->
          walk(grandchild, node, depth + 1) if grandchild and typeof grandchild.type is 'string'

      else if child? and typeof child.type is 'string'
        postfunc.call(@, child, node, chunks, depth) if postfunc?
        walk(child, node, depth)

    prefunc.call(@, node, parent, chunks) if prefunc?

  walk(ast)

util.scopeLookup = (node, scopes) ->
  itr = node
  while itr?
    scope = _.find scopes, (value, key) ->
      return value.node == itr

    break if scope?
    itr = itr.parent

  scope or scopes['global']

util.scopeName = (name, scope) ->
  while scope? and scope.name isnt 'global'
    name = scope.name + '.' + name
    scope = scope.parent
  name

util.allSame = (list) ->
  return _.all list, (item) ->
    item is list[0]

util.objGet = (obj, path) ->
  segments = path.split '.'
  while segments.length and obj?
    obj = obj[segments.shift()]
  obj

util.objSet = (obj, path, value) ->
  segments = path.split '.'
  while segments.length > 1
    segment = segments.shift()
    obj[segment] = obj[segment] or {}
    obj = obj[segment]
  obj[segments[0]] = value

GLOBAL.util = util
